== JVM initialization

=== OopMaps
=== safepoint 

// Roll all threads forward to a safepoint and suspend them all
void SafepointSynchronize::begin() 


//  1. Running interpreted
//     When executing branching/returning byte codes interpreter
//     checks if the poll is armed, if so blocks in SS::block().
//  2. Running in native code
//     When returning from the native code, a Java thread must check
//     the safepoint _state to see if we must block.  If the
//     VM thread sees a Java thread in native, it does
//     not wait for this thread to block.  The order of the memory
//     writes and reads of both the safepoint state and the Java
//     threads state is critical.  In order to guarantee that the
//     memory writes are serialized with respect to each other,
//     the VM thread issues a memory barrier instruction.
//  3. Running compiled Code
//     Compiled code reads the local polling page that
//     is set to fault if we are trying to get to a safepoint.
//  4. Blocked
//     A thread which is blocked will not be allowed to return from the
//     block condition until the safepoint operation is complete.
//  5. In VM or Transitioning between states
//     If a Java thread is currently running in the VM or transitioning
//     between states, the safepointing code will poll the thread state
//     until the thread blocks itself when it attempts transitions to a
//     new state or locking a safepoint checked monitor.

// during creating vm 
// SafepointMechanism::default_initialize
// process
// The call to on_safepoint fixes the thread's oops and the first few frames.
//
// The call has been carefully placed here to cater to a few situations:
// 1) After we exit from block after a global poll
// 2) After a thread races with the disarming of the global poll and transitions from native/blocked
// 3) Before the handshake code is run
//A compiler barrier, forcing the C++ compiler to invalidate all memory assumptions
// void SafepointMechanism::process(JavaThread *thread, bool allow_suspend) 

// Wait for another thread to perform object reallocation and relocking on behalf of
// this thread.
// Raw thread state transition to _thread_blocked and back again to the original
// state before returning are performed. The current thread is required to
// change to _thread_blocked in order to be seen to be safepoint/handshake safe
// whilst suspended and only after becoming handshake safe, the other thread can
// complete the handshake used to synchronize with this thread and then perform
// the reallocation and relocking. We cannot use the thread state transition
// helpers because we arrive here in various states and also because the helpers
// indirectly call this method.  After leaving _thread_blocked we have to check
// for safepoint/handshake, except if _thread_in_native. The thread is safe
// without blocking then. Allowed states are enumerated in
// SafepointSynchronize::block(). See also EscapeBarrier::sync_and_suspend_*()


ParallelSPCleanupThreadClosure

=== stack processing

During safepoint 

=== but not with Shenandoah and ZGC 
// JavaThread::wait_for_object_deoptimization
// SafepointMechanism::process(JavaThread *thread, bool allow_suspend)
// (reachability) ( void StackWatermark::start_processing_impl(void* context) (TODO)
