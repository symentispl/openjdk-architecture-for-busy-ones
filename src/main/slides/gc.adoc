== Garbage collection 

* OopMaps
* safepoint -> kiedy sÄ… sprawdzane
* stack processing (reachability)
* root, heap
* bariery?
* card table / card marking
* TLAB (inside & outside)

== How GC start?

=== init globals 

=== universe init

=== initialize_global_behaviours

=== GCLogPrecious::initialize();

=== Initialize heap size

// GCConfig::arguments()->initialize_heap_sizes();
Memory Aligment, new Ratio, Min/Max Heap Size
// Based on arguments JVM try to figure out what exactly arguments should be appled
// There is also assertion checking proper configuration like MaxHeapSize should be greater 
// Also that proprotion like newRatio etc.
// Also there is memory aligment 
// Parallel
// The card marking array and the offset arrays for old generations are
// committed in os pages as well. Make sure they are entirely full (to
// avoid partial page problems), e.g. if 512 bytes heap corresponds to 1
// byte entry and the os page size is 4096, the maximum heap size should
// be 512*4096 = 2MB aligned.

=== Initalize heap 

// Universe::initialize_heap(); GCConfig::arguments()->create_heap(); _collectedHeap->initialize()
Based on argument gc algorithm is choosen and used to initlize heap.

// It used Strategy Pattern as way to handle this case. 
// Basiclly created heap is simple object represents process to create the heap related to pariticular version
// Based on G1
// There is created sometimes mutex 
// Initialize reserved regions, then created card table, then created G1 barrier set ( STB, DIRTY CARD), hot card table cache, and space mapper 
// Based on ZGC
// Register soft reference policy, barrier set, driver, director. Driver contains all phases necessary to make GC cycle. ZDriver contains procedures to collecting heap. ZDirector has additional role, it supervisior also but calculate how many threads are created for GC algorithms, contains diffrents heuristics, read statistics and makes decisions based on these metrics. It works proactive 


=== TLAB 

//  Universe::initialize_tlab();
Thread Local Allocation Buffer 
// There is calculate size of TLAB 
// When C2 is enabled more space is necessary in TLAB otherwise prefetching intructions generated by C2 compiler 
// will fault ( due to accessing memory outside of heap )

=== Metaspace 

//  Metaspace::global_initialize();

=== MetaspaceCounters::initialize_performance_counters();

=== JVMFlagLimit::check_all_constraints 

=== ClassLoaderData::init_null_class_loader_data();

=== MetaspaceShared::initialize_shared_spaces();

=== StringTable::create_table();

=== SymbolTable::create_table();

=== StringTable::create_table();


=== Arguments::is_dumping_archive()) {

=== MetaspaceShared::prepare_for_dumping();

=== Universe::initialize_verify_flags();
  
=== ResolvedMethodTable::create_table();
