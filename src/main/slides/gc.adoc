== garbage collection 
The problem is there!

=== heap

Heap is initilized during creating the Universe. 

==== GC 
// init globals 
// universe init
// initialize_global_behaviours
// GCLogPrecious::initialize();
// Initialize heap size

// GCConfig::arguments()->initialize_heap_sizes();
// Memory Aligment, new Ratio, Min/Max Heap Size
// Based on arguments JVM try to figure out what exactly arguments should be appled
// There is also assertion checking proper configuration like MaxHeapSize should be greater 
// Also that proprotion like newRatio etc.
// Also there is memory aligment 
// Parallel
// The card marking array and the offset arrays for old generations are
// committed in os pages as well. Make sure they are entirely full (to
// avoid partial page problems), e.g. if 512 bytes heap corresponds to 1
// byte entry and the os page size is 4096, the maximum heap size should
// be 512*4096 = 2MB aligned.

// Initalize heap 

// Universe::initialize_heap(); GCConfig::arguments()->create_heap(); _collectedHeap->initialize()


// It used Strategy Pattern as way to handle this case. 
// Basiclly created heap is simple object represents process to create the heap related to pariticular version
// Based on G1
// There is created sometimes mutex 
// Initialize reserved regions, then created card table, then created G1 barrier set ( STB, DIRTY CARD), hot card table cache, and space mapper 
// Based on ZGC
// Register soft reference policy, barrier set, driver, director. Driver contains all phases necessary to make GC cycle. ZDriver contains procedures to collecting heap. ZDirector has additional role, it supervisior also but calculate how many threads are created for GC algorithms, contains diffrents heuristics, read statistics and makes decisions based on these metrics. It works proactive 


 


=== roots
Root is basic concept in GC cycle

Root is thread, local variables, static fields, final fields. 

==== VM threads are roots

=== bariers
Barriers need JIT help without JIT barriers can be useful. 

==== G1, Shendandoah, ZGC 
Only these GCs use barriers 

==== Barrier
Barrier is simple assmebly code injected in particular place 
G1 uses load/store (aka read/write) barriers
Shenandoah and ZGC uses load barrier 


TODO wrzuc przyklad asseemblera 


===  card table

After creating heap starting process to collecting heap. 
Card table needs additional memory space, if doesn't VM exit 

===  TLAB 

Thread Local Allocation Buffer 

==== Each thread has own space to allocate

If object is too big then allocation is outside of TLAB

==== Outside TLAB allocation 
We need take slow path it means 


//  Universe::initialize_tlab();

// There is calculate size of TLAB 
// When C2 is enabled more space is necessary in TLAB otherwise prefetching intructions generated by C2 compiler 
// will fault ( due to accessing memory outside of heap )

// Metaspace 

//  Metaspace::global_initialize();

// MetaspaceCounters::initialize_performance_counters();

// JVMFlagLimit::check_all_constraints 

// ClassLoaderData::init_null_class_loader_data();

// MetaspaceShared::initialize_shared_spaces();

// StringTable::create_table();

// SymbolTable::create_table();

// StringTable::create_table();


// Arguments::is_dumping_archive()) {
// MetaspaceShared::prepare_for_dumping();

// Universe::initialize_verify_flags();
  
//ResolvedMethodTable::create_table();



==== TLAB Size
During starting the Universe then TLAB size is calculated 
==== TLAB Size recalculting 
Every FullGC 
// ThreadLocalAllocBuffer::startup_initialization

==== Take off TLAB 
It not good idea

===== JIT 
If C2 is enabled extra space is needed otherwise prefetching instructions generated by the C2
compiler will fault 


==== Retrie TLAB

GC can retire TLAB space but only 
ZGC and Shenandoah retries space during concurrent stack processing 
