== heap

Heap is initialized during the creation of the Universe

=== universe_post_init

`src/hotspot/share/memory/universe.cpp`

=== GC 

An GC algorithm is chosen during creation of the Universe

image::https://media0.giphy.com/media/xUPGctUP1Z50BNlEpa/giphy.gif[background]

=== ! 

But sometimes is different what we expect 

Ergo, ergo, ergo.. 

image::https://media.makeameme.org/created/kubernetes-take.jpg[]

// init globals 
// universe init
// initialize_global_behaviours
// GCLogPrecious::initialize();
// Initialize heap size

// GCConfig::arguments()->initialize_heap_sizes();
// Memory Aligment, new Ratio, Min/Max Heap Size
// Based on arguments JVM try to figure out what exactly arguments should be appled
// There is also assertion checking proper configuration like MaxHeapSize should be greater 
// Also that proprotion like newRatio etc.
// Also there is memory aligment 
// Parallel
// The card marking array and the offset arrays for old generations are
// committed in os pages as well. Make sure they are entirely full (to
// avoid partial page problems), e.g. if 512 bytes heap corresponds to 1
// byte entry and the os page size is 4096, the maximum heap size should
// be 512*4096 = 2MB aligned.

// Initalize heap 

// Universe::initialize_heap(); GCConfig::arguments()->create_heap(); _collectedHeap->initialize()


// It used Strategy Pattern as way to handle this case. 
// Basiclly created heap is simple object represents process to create the heap related to pariticular version
// Based on G1
// There is created sometimes mutex 
// Initialize reserved regions, then created card table, then created G1 barrier set ( STB, DIRTY CARD), hot card table cache, and space mapper 
// Based on ZGC
// Register soft reference policy, barrier set, driver, director. Driver contains all phases necessary to make GC cycle. ZDriver contains procedures to collecting heap. ZDirector has additional role, it supervisior also but calculate how many threads are created for GC algorithms, contains diffrents heuristics, read statistics and makes decisions based on these metrics. It works proactive 


 


=== roots

The root is a basic concept in the GC cycle

Root is thread, local variables, static fields, final fields. 

=== VM threads are roots

=== bariers

Barriers need Jthe IT help for speed

image::https://media2.giphy.com/media/wLJSjc5fzMJtS/giphy.gif[background]


=== !

G1, Shendandoah, ZGC 

Only these GCs use barriers 

=== !

Barriers

Barrier is simple assmebly code injected in particular place 
G1 uses load/store (aka read/write) barriers
Shenandoah and ZGC uses load barrier 

[source,assembly]
----

0x00007fabf9777f48:   mov    -0x28(%rbp),%rbx
0x00007fabf9777f4c:   test   %rbx,%rbx
0x00007fabf9777f4f:   je     0x00007fabf9777fdc
----

===  card table

After creating heap starting process to collecting heap. 
Card table needs additional memory space, if doesn't VM exit 

=== !

TLAB 

Thread Local Allocation Buffer 

image::https://media2.giphy.com/media/kf4SXNzSfiAiQ/giphy.gif[background]


=== !

Each thread has own space to allocate

If object is too big then allocation is outside of TLAB

-----
// Load the current thread-local allocation pointer
mov     0x118(%r15),%rax

// Compute new thread-local allocation pointer by adding allocation size (16 bytes)
mov     %rax,%r10
add     $0x10,%r10
-----

=== !

Outside TLAB allocation (aka global allocation)

We need take slow path it means 


//  Universe::initialize_tlab();

// There is calculate size of TLAB 
// When C2 is enabled more space is necessary in TLAB otherwise prefetching intructions generated by C2 compiler 
// will fault ( due to accessing memory outside of heap )

// Metaspace 

//  Metaspace::global_initialize();

// MetaspaceCounters::initialize_performance_counters();

// JVMFlagLimit::check_all_constraints 

// ClassLoaderData::init_null_class_loader_data();

// MetaspaceShared::initialize_shared_spaces();

// StringTable::create_table();

// StringTable::create_table();


// Arguments::is_dumping_archive()) {
// MetaspaceShared::prepare_for_dumping();

// Universe::initialize_verify_flags();
  
//ResolvedMethodTable::create_table();



=== !

TLAB Size

During starting the Universe then TLAB size is calculated 

`src/hotspot/share/gc/shared/threadLocalAllocBuffer.cpp`

[source,cpp]
-----
size_t ThreadLocalAllocBuffer::initial_desired_size() {
  size_t init_sz = 0;

  if (TLABSize > 0) {
    init_sz = TLABSize / HeapWordSize;
  } else {
 
    unsigned int nof_threads = ThreadLocalAllocStats::allocating_threads_avg();

    init_sz  = (Universe::heap()->tlab_capacity(thread()) / HeapWordSize) /
                      (nof_threads * target_refills());
    init_sz = align_object_size(init_sz);
  }
  init_sz = MIN2(MAX2(init_sz, min_size()), max_size());
  return init_sz;
}
-----

=== !

TLAB Size recalculting 

Every full GC cycle TLAB is resizing if needed 

// ThreadLocalAllocBuffer::startup_initialization

=== !

Take off TLAB 

It not good idea

=== !

JIT 

If C2 is enabled extra space is needed otherwise prefetching instructions generated by the C2
compiler will fault 


`src/hotspot/share/gc/g1/c1` +
`src/hotspot/share/gc/g1/c2` + 

`src/hotspot/share/gc/shenandoah/c1` + 
`src/hotspot/share/gc/shenandoah/c2` + 

`src/hotspot/share/gc/z/c1` + 
`src/hotspot/share/gc/z/c2` + 

=== Retrie TLAB

GC can retire TLAB space but only  +
ZGC and Shenandoah retries space during concurrent stack  processing

---